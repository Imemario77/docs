This guide explains how to enhance your VAPI voice assistant by dynamically incorporating customer-specific information into conversations. 
By implementing this feature, your voice AI can reference personal details, or account information during calls, 
creating a personalized experience that leaves customers feeling understood and valued.

## Understanding the Personalization Flow

When a customer calls your VAPI phone number, here's what happens:

1. VAPI receives the incoming call and identifies the destination phone number
2. Instead of using a hardcoded assistant, VAPI sends a request to your server
3. Your server identifies the caller, retrieves their information, and returns either:
   - An existing assistant ID with dynamic variable values, or
   - A complete transient assistant configuration with embedded customer data
4. VAPI processes this response and handles the call using the personalized assistant
5. The customer experiences a conversation tailored specifically to them

This dynamic approach enables you to deliver personalized experiences without creating a separate assistant for each customer. Let's explore how to implement each piece of this system.

## Prerequisites

- A phone number (either purchased through VAPI or imported)
- A created VAPI Assistant (for the existing assistant approach)
- A server endpoint that can receive VAPI's requests

## Understanding Dynamic Variables

At the heart of this feature is VAPI's template variable system, which allows you to insert placeholders in your assistant's instructions that get replaced with real customer data at runtime.

### Variable Syntax

```
{{variable_name}}
```

**Important:** Use exactly this format without additional characters. Any deviation will break the functionality.

## Implementation 

### 1. Adding Dynamic Variables to Your Assistant

First, you need to prepare your assistant to accept dynamic information by adding variable placeholders to its instructions.

1. Navigate to the Assistants section in your VAPI dashboard
2. Edit your existing assistant
3. In the system instructions, include variables using the `{{variable_name}}` syntax
   - Example: "Hello {{customerName}}! I see you've been a {{accountType}} customer since {{joinDate}}."
4. Save your assistant and note its ID - you'll need this ID in your server implementation

Why this matters: These variables serve as placeholders that will be replaced with actual customer data when a call is received. Without these placeholders, your assistant would deliver the same generic experience to every caller.

### 2. Configuring Your Phone Number

Next, you need to configure your phone number to use your server instead of a hardcoded assistant. This is what enables the dynamic assistant selection process.


#### API Method:

```javascript
PATCH /phone-number/{id}
{
  "assistantId": null,
  "squadId": null,
  "server": {
    "url": "https://your-server.com/api/assistant-selector"
  }
}
```

**Note:** The server timeout is fixed at 7.5 seconds by default and cannot be configured.

Why this matters: By removing the hardcoded assistant and adding a server URL, you're telling VAPI to ask your server what assistant to use for each call. This is what transforms a static assistant into a dynamic, personalized experience.

### 3. Implementing Your Server Endpoint

Now for the crucial part - your server endpoint that will receive call information and return a personalized assistant configuration. When someone calls your VAPI number, VAPI will make an HTTP POST request to your server URL with information about the call, including the caller's phone number.

Your endpoint needs to:

1. Verify it's an assistant request from VAPI
2. Extract the caller's phone number
3. Look up the customer in your system (CRM, database, etc.)
4. Return either a pre-created assistant with variables or a complete assistant configuration

You have two approaches for personalizing the call:

#### Method 1: Returning an Existing Assistant with Variable Overrides

This approach is ideal when you want to maintain your assistant configuration in the VAPI dashboard while dynamically injecting customer-specific information:

```javascript
app.post("/api/assistant-selector", async (req, res) => {
  // Verify this is an assistant request from VAPI
  // This structure comes from the ServerMessage class in message.types.ts
  if (req.body.message && req.body.message.type === "assistant-request") {
    try {
      // Extract caller information from the request
      const callDetails = req.body.call;
      const phoneNumber = callDetails.from.phoneNumber;

      // Look up customer in your CRM or database
      const customer = await crmAPI.getCustomerByPhone(phoneNumber);

      // Return your pre-created assistant ID with personalized variables
      // This follows the AssistantRequestMessageResponse structure
      res.json({
        assistantId: "asst_customersupport", // ID of your pre-created assistant
        assistantOverrides: {
          variableValues: {
            customerName: customer.name,
            accountType: customer.tier,
            joinDate: customer.createdAt,
            openTickets: customer.tickets.filter((t) => t.status === "open")
              .length,
          },
        },
      });
    } catch (error) {
      // Return error response - this will be spoken to the customer
      res.json({
        error: "Customer lookup failed. Please try again later.",
      });
    }
  } else {
    res.status(400).json({
      error: "Invalid request type",
    });
  }
});
```

Why this matters: This method lets you maintain a single assistant template in the VAPI dashboard while injecting customer-specific data at runtime. The variables in your assistant's instructions will be replaced with the values you provide in `variableValues`.

#### Method 2: Returning a Complete Transient Assistant

This approach gives you maximum flexibility by constructing the entire assistant configuration on the fly:

```javascript
app.post("/api/assistant-selector", async (req, res) => {
  // Verify this is an assistant request from VAPI
  // This structure comes from the ServerMessage class in message.types.ts
  if (req.body.message && req.body.message.type === "assistant-request") {
    try {
      // Extract caller information from the request
      const callDetails = req.body.call;
      const phoneNumber = callDetails.from.phoneNumber;

      // Look up customer in your CRM or database
      const customer = await crmAPI.getCustomerByPhone(phoneNumber);

      // Return a complete transient assistant configuration
      // This follows the CreateAssistantDTO structure from assistant.types.ts
      res.json({
        assistant: {
          name: "Dynamic Customer Support Assistant",
          model: {
            provider: "openai",
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are a helpful customer support agent for TechCo. 
                            The customer's name is ${customer.name} and they are a 
                            ${customer.tier} member since ${customer.createdAt}.`,
              },
            ],
          },
          voice: {
            provider: "11labs",
            voiceId: "shimmer",
          },
        },
      });
    } catch (error) {
      // Return error response - this will be spoken to the customer
      res.json({
        error: "Customer lookup failed. Please try again later.",
      });
    }
  } else {
    res.status(400).json({
      error: "Invalid request type",
    });
  }
});
```

Why this matters: This method gives you complete control over the assistant configuration for each call. Instead of relying on a pre-created assistant, you're building the entire assistant from scratch for each caller, which can be useful for highly customized experiences or when your assistant configuration itself needs to vary by customer.

## What Happens During a Call

Let's walk through what happens when a call comes in:

1. Customer dials your VAPI phone number
2. VAPI receives the call and identifies which phone number was called
3. VAPI checks the phone number configuration and sees it has a server URL
4. VAPI sends a POST request to your server URL with details about the call, including the caller's phone number
5. Your server receives this request and looks up the customer in your system
6. Your server returns either an existing assistant ID with variable values or a complete assistant configuration
7. VAPI processes this response and initializes the assistant with the personalized information
8. The call proceeds with the personalized assistant handling the conversation

This entire process happens in seconds, creating a seamless experience for your caller while delivering personalized service.

## Technical Constraints

### Response Time

Your server endpoint must return a response within 7.5 seconds. If your endpoint takes longer, VAPI will time out and the call will fall back to default behavior.

### Error Handling

If you need to return an error response for an assistant request, use the following format:

```json
{
  "error": "Unable to find customer record. Please try again later."
}
```

This error message will be spoken to the customer, and the call will be ended.

## Troubleshooting

### Common Issues

- **Variables not resolving:** Check for exact syntax: `{{variable_name}}`
- **Timeout errors:** Optimize database queries; consider caching frequent lookups
- **Missing customer data:** Implement fallbacks for each variable
- **Call failures:** Ensure your endpoint has high availability and proper error handling
