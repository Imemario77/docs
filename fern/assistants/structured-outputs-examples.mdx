---
title: Structured outputs examples
subtitle: Real-world examples and templates for common use cases
slug: assistants/structured-outputs-examples
---

## Overview

This page provides production-ready examples of structured outputs for common business scenarios. Each example includes the complete schema, configuration, and integration code.

## Healthcare appointment booking

Extract patient information and appointment preferences from healthcare calls.

<CodeBlocks>
```json title="Schema"
{
  "name": "Healthcare Appointment",
  "type": "ai",
  "description": "Extract patient and appointment information for medical scheduling",
  "schema": {
    "type": "object",
    "properties": {
      "patient": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string",
            "description": "Patient's first name"
          },
          "lastName": {
            "type": "string",
            "description": "Patient's last name"
          },
          "dateOfBirth": {
            "type": "string",
            "format": "date",
            "description": "Patient's date of birth (YYYY-MM-DD)"
          },
          "phoneNumber": {
            "type": "string",
            "pattern": "^\\+?[1-9]\\d{1,14}$",
            "description": "Patient's contact number"
          },
          "insuranceProvider": {
            "type": "string",
            "description": "Insurance provider name"
          },
          "memberID": {
            "type": "string",
            "description": "Insurance member ID"
          }
        },
        "required": ["firstName", "lastName", "phoneNumber"]
      },
      "appointment": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["new-patient", "follow-up", "annual-checkup", "urgent-care", "specialist"],
            "description": "Type of appointment"
          },
          "department": {
            "type": "string",
            "enum": ["general", "cardiology", "dermatology", "orthopedics", "pediatrics", "obgyn"],
            "description": "Medical department"
          },
          "preferredDates": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "date"
            },
            "maxItems": 3,
            "description": "Up to 3 preferred appointment dates"
          },
          "preferredTimeSlot": {
            "type": "string",
            "enum": ["morning", "afternoon", "evening", "any"],
            "description": "Preferred time of day"
          },
          "symptoms": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of symptoms or reasons for visit"
          },
          "urgency": {
            "type": "string",
            "enum": ["routine", "soon", "urgent"],
            "description": "How urgent is the appointment"
          }
        },
        "required": ["type", "department", "urgency"]
      },
      "additionalNotes": {
        "type": "string",
        "description": "Any additional notes or special requirements"
      }
    },
    "required": ["patient", "appointment"]
  }
}
```

```javascript title="Integration Example"
// Process extracted healthcare appointment data
function processHealthcareAppointment(extractedData) {
  const { patient, appointment } = extractedData;
  
  // Create patient record if new
  if (appointment.type === 'new-patient') {
    createPatientRecord(patient);
  }
  
  // Check insurance eligibility
  if (patient.insuranceProvider && patient.memberID) {
    verifyInsurance(patient.insuranceProvider, patient.memberID);
  }
  
  // Find available slots
  const availableSlots = findAppointmentSlots({
    department: appointment.department,
    dates: appointment.preferredDates,
    timeSlot: appointment.preferredTimeSlot,
    duration: appointment.type === 'new-patient' ? 60 : 30
  });
  
  // Handle urgent cases
  if (appointment.urgency === 'urgent') {
    prioritizeAppointment(patient, appointment);
    notifyOnCallStaff(appointment.department, appointment.symptoms);
  }
  
  return {
    patientId: patient.id,
    appointmentOptions: availableSlots,
    requiresPreAuth: checkPreAuthorization(appointment.type, patient.insuranceProvider)
  };
}
```
</CodeBlocks>

## E-commerce order processing

Capture order details, shipping information, and payment preferences.

<CodeBlocks>
```json title="Schema"
{
  "name": "E-commerce Order",
  "type": "ai",
  "description": "Extract complete order information from sales calls",
  "schema": {
    "type": "object",
    "properties": {
      "customer": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Customer full name"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Customer email for order confirmation"
          },
          "phone": {
            "type": "string",
            "description": "Contact number"
          },
          "loyaltyNumber": {
            "type": "string",
            "description": "Loyalty program member number if mentioned"
          }
        },
        "required": ["name", "email"]
      },
      "items": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "productName": {
              "type": "string",
              "description": "Name or description of the product"
            },
            "sku": {
              "type": "string",
              "description": "Product SKU if mentioned"
            },
            "quantity": {
              "type": "integer",
              "minimum": 1,
              "description": "Quantity ordered"
            },
            "size": {
              "type": "string",
              "enum": ["XS", "S", "M", "L", "XL", "XXL", "custom"],
              "description": "Size if applicable"
            },
            "color": {
              "type": "string",
              "description": "Color preference"
            },
            "customization": {
              "type": "string",
              "description": "Any customization requests"
            }
          },
          "required": ["productName", "quantity"]
        },
        "minItems": 1,
        "description": "List of items being ordered"
      },
      "shipping": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "enum": ["standard", "express", "overnight", "pickup"],
            "description": "Shipping method"
          },
          "address": {
            "type": "object",
            "properties": {
              "street": {
                "type": "string"
              },
              "apartment": {
                "type": "string",
                "description": "Apartment or suite number"
              },
              "city": {
                "type": "string"
              },
              "state": {
                "type": "string",
                "pattern": "^[A-Z]{2}$"
              },
              "zipCode": {
                "type": "string",
                "pattern": "^\\d{5}(-\\d{4})?$"
              },
              "country": {
                "type": "string",
                "default": "USA"
              }
            },
            "required": ["street", "city", "state", "zipCode"]
          },
          "instructions": {
            "type": "string",
            "description": "Special delivery instructions"
          },
          "giftWrap": {
            "type": "boolean",
            "description": "Whether gift wrapping was requested"
          },
          "giftMessage": {
            "type": "string",
            "description": "Gift message if applicable"
          }
        },
        "required": ["method", "address"]
      },
      "payment": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "enum": ["credit_card", "debit_card", "paypal", "apple_pay", "google_pay", "invoice"],
            "description": "Payment method"
          },
          "cardLastFour": {
            "type": "string",
            "pattern": "^\\d{4}$",
            "description": "Last 4 digits of card if provided"
          },
          "billingAddressSameAsShipping": {
            "type": "boolean",
            "description": "Whether billing address is same as shipping"
          }
        },
        "required": ["method"]
      },
      "promotions": {
        "type": "object",
        "properties": {
          "promoCode": {
            "type": "string",
            "description": "Promotional code mentioned"
          },
          "referralSource": {
            "type": "string",
            "description": "How customer heard about us"
          }
        }
      },
      "specialRequests": {
        "type": "string",
        "description": "Any special requests or notes"
      }
    },
    "required": ["customer", "items", "shipping"]
  }
}
```

```python title="Integration Example"
def process_ecommerce_order(extracted_data):
    """Process extracted e-commerce order data"""
    
    # Validate inventory
    for item in extracted_data['items']:
        stock = check_inventory(
            product=item['productName'],
            quantity=item['quantity'],
            size=item.get('size'),
            color=item.get('color')
        )
        
        if not stock['available']:
            suggest_alternatives(item, stock['alternatives'])
    
    # Calculate pricing
    subtotal = calculate_subtotal(extracted_data['items'])
    shipping_cost = calculate_shipping(
        method=extracted_data['shipping']['method'],
        address=extracted_data['shipping']['address'],
        items=extracted_data['items']
    )
    
    # Apply promotions
    discount = 0
    if promo_code := extracted_data.get('promotions', {}).get('promoCode'):
        discount = apply_promo_code(promo_code, subtotal)
    
    # Apply loyalty benefits
    if loyalty_num := extracted_data['customer'].get('loyaltyNumber'):
        loyalty_discount = calculate_loyalty_discount(loyalty_num, subtotal)
        discount += loyalty_discount
    
    # Create order
    order = {
        'customer': extracted_data['customer'],
        'items': extracted_data['items'],
        'shipping': extracted_data['shipping'],
        'payment': extracted_data['payment'],
        'subtotal': subtotal,
        'shipping_cost': shipping_cost,
        'discount': discount,
        'total': subtotal + shipping_cost - discount,
        'status': 'pending_payment'
    }
    
    # Handle gift orders
    if extracted_data['shipping'].get('giftWrap'):
        order['gift_options'] = {
            'wrap': True,
            'message': extracted_data['shipping'].get('giftMessage')
        }
    
    return create_order_record(order)
```
</CodeBlocks>

## Real estate lead qualification

Qualify real estate leads and capture property preferences.

<CodeBlocks>
```json title="Schema"
{
  "name": "Real Estate Lead",
  "type": "ai",
  "description": "Qualify real estate leads and extract property preferences",
  "schema": {
    "type": "object",
    "properties": {
      "contact": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string"
          },
          "lastName": {
            "type": "string"
          },
          "email": {
            "type": "string",
            "format": "email"
          },
          "phone": {
            "type": "string"
          },
          "preferredContactMethod": {
            "type": "string",
            "enum": ["phone", "email", "text", "any"]
          },
          "bestTimeToContact": {
            "type": "string",
            "enum": ["morning", "afternoon", "evening", "weekends", "any"]
          }
        },
        "required": ["firstName", "phone"]
      },
      "propertySearch": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["buy", "rent", "sell", "invest"]
          },
          "propertyType": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["single-family", "condo", "townhouse", "multi-family", "commercial", "land"]
            }
          },
          "locations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "area": {
                  "type": "string",
                  "description": "Neighborhood, city, or region"
                },
                "schools": {
                  "type": "boolean",
                  "description": "Important to be near good schools"
                },
                "commute": {
                  "type": "string",
                  "description": "Commute requirements mentioned"
                }
              }
            }
          },
          "budget": {
            "type": "object",
            "properties": {
              "min": {
                "type": "number",
                "minimum": 0
              },
              "max": {
                "type": "number"
              },
              "preApproved": {
                "type": "boolean",
                "description": "Whether they have mortgage pre-approval"
              }
            }
          },
          "features": {
            "type": "object",
            "properties": {
              "bedrooms": {
                "type": "integer",
                "minimum": 0
              },
              "bathrooms": {
                "type": "number",
                "minimum": 0
              },
              "squareFeet": {
                "type": "integer",
                "minimum": 0
              },
              "garage": {
                "type": "boolean"
              },
              "pool": {
                "type": "boolean"
              },
              "yard": {
                "type": "boolean"
              },
              "mustHaves": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "List of must-have features"
              },
              "dealBreakers": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "List of deal-breakers"
              }
            }
          }
        },
        "required": ["type", "propertyType", "budget"]
      },
      "timeline": {
        "type": "object",
        "properties": {
          "urgency": {
            "type": "string",
            "enum": ["immediate", "1-3months", "3-6months", "6-12months", "browsing"]
          },
          "moveInDate": {
            "type": "string",
            "format": "date",
            "description": "Target move-in date if mentioned"
          },
          "reason": {
            "type": "string",
            "description": "Reason for moving/buying"
          }
        }
      },
      "currentSituation": {
        "type": "object",
        "properties": {
          "currentlyOwns": {
            "type": "boolean",
            "description": "Whether they currently own property"
          },
          "needToSell": {
            "type": "boolean",
            "description": "Need to sell before buying"
          },
          "firstTimeBuyer": {
            "type": "boolean"
          }
        }
      },
      "leadScore": {
        "type": "object",
        "properties": {
          "motivation": {
            "type": "string",
            "enum": ["high", "medium", "low"],
            "description": "Buyer/seller motivation level"
          },
          "qualified": {
            "type": "boolean",
            "description": "Whether lead seems qualified"
          },
          "followUpPriority": {
            "type": "string",
            "enum": ["hot", "warm", "cold"],
            "description": "Follow-up priority"
          }
        }
      }
    },
    "required": ["contact", "propertySearch", "timeline"]
  }
}
```

```javascript title="Integration Example"
// CRM integration for real estate leads
async function processRealEstateLead(extractedData) {
  const { contact, propertySearch, timeline, currentSituation, leadScore } = extractedData;
  
  // Score the lead
  const score = calculateLeadScore({
    budget: propertySearch.budget,
    timeline: timeline.urgency,
    preApproved: propertySearch.budget?.preApproved,
    motivation: leadScore?.motivation,
    currentlyOwns: currentSituation?.currentlyOwns
  });
  
  // Search matching properties
  const matchingProperties = await searchProperties({
    type: propertySearch.propertyType,
    locations: propertySearch.locations.map(l => l.area),
    priceRange: {
      min: propertySearch.budget.min,
      max: propertySearch.budget.max
    },
    features: {
      minBedrooms: propertySearch.features?.bedrooms,
      minBathrooms: propertySearch.features?.bathrooms,
      mustHaves: propertySearch.features?.mustHaves
    }
  });
  
  // Create lead in CRM
  const leadId = await createCRMLead({
    contact,
    score,
    propertyPreferences: propertySearch,
    timeline,
    assignedAgent: selectBestAgent(propertySearch.locations, propertySearch.type)
  });
  
  // Set up automated follow-up
  if (timeline.urgency === 'immediate' || leadScore?.followUpPriority === 'hot') {
    scheduleImmediateCallback(leadId, contact);
    sendPropertyMatches(contact.email, matchingProperties.slice(0, 5));
  } else {
    scheduleDripCampaign(leadId, timeline.urgency);
  }
  
  // Handle special situations
  if (currentSituation?.firstTimeBuyer) {
    sendFirstTimeBuyerGuide(contact.email);
  }
  
  if (currentSituation?.needToSell) {
    scheduleListingConsultation(leadId);
  }
  
  return {
    leadId,
    score,
    matchingProperties: matchingProperties.length,
    assignedAgent: leadId.agent,
    nextAction: determineNextAction(score, timeline)
  };
}
```
</CodeBlocks>

## Insurance claim intake

Capture insurance claim details and incident information.

<CodeBlocks>
```json title="Schema"
{
  "name": "Insurance Claim",
  "type": "ai",
  "description": "Extract insurance claim information and incident details",
  "schema": {
    "type": "object",
    "properties": {
      "policyholder": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "policyNumber": {
            "type": "string",
            "description": "Insurance policy number"
          },
          "dateOfBirth": {
            "type": "string",
            "format": "date"
          },
          "contactPhone": {
            "type": "string"
          },
          "email": {
            "type": "string",
            "format": "email"
          }
        },
        "required": ["name", "policyNumber"]
      },
      "incident": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["auto", "property", "theft", "injury", "liability", "other"]
          },
          "date": {
            "type": "string",
            "format": "date",
            "description": "Date of incident"
          },
          "time": {
            "type": "string",
            "format": "time",
            "description": "Approximate time of incident"
          },
          "location": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "city": {
                "type": "string"
              },
              "state": {
                "type": "string"
              },
              "zipCode": {
                "type": "string"
              }
            }
          },
          "description": {
            "type": "string",
            "description": "Detailed description of what happened"
          },
          "policeReportFiled": {
            "type": "boolean"
          },
          "policeReportNumber": {
            "type": "string",
            "description": "Police report number if available"
          }
        },
        "required": ["type", "date", "description"]
      },
      "damages": {
        "type": "object",
        "properties": {
          "propertyDamage": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "item": {
                  "type": "string",
                  "description": "Damaged item or property"
                },
                "estimatedValue": {
                  "type": "number",
                  "description": "Estimated value or repair cost"
                },
                "description": {
                  "type": "string",
                  "description": "Description of damage"
                }
              }
            }
          },
          "injuries": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "person": {
                  "type": "string",
                  "description": "Injured person's name"
                },
                "relationship": {
                  "type": "string",
                  "enum": ["self", "family", "passenger", "pedestrian", "other-driver", "other"],
                  "description": "Relationship to policyholder"
                },
                "injuryDescription": {
                  "type": "string"
                },
                "medicalTreatment": {
                  "type": "boolean",
                  "description": "Whether medical treatment was received"
                },
                "hospital": {
                  "type": "string",
                  "description": "Hospital or clinic name if treated"
                }
              }
            }
          },
          "estimatedTotalLoss": {
            "type": "number",
            "description": "Total estimated loss amount"
          }
        }
      },
      "otherParties": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "role": {
              "type": "string",
              "enum": ["other-driver", "witness", "property-owner", "passenger"],
              "description": "Role in incident"
            },
            "contactInfo": {
              "type": "string",
              "description": "Phone or email"
            },
            "insuranceCompany": {
              "type": "string",
              "description": "Their insurance company if known"
            },
            "policyNumber": {
              "type": "string",
              "description": "Their policy number if known"
            }
          }
        }
      },
      "documentation": {
        "type": "object",
        "properties": {
          "photosAvailable": {
            "type": "boolean"
          },
          "receiptsAvailable": {
            "type": "boolean"
          },
          "witnessStatements": {
            "type": "boolean"
          }
        }
      },
      "urgency": {
        "type": "string",
        "enum": ["emergency", "urgent", "standard"],
        "description": "Claim urgency level"
      }
    },
    "required": ["policyholder", "incident"]
  }
}
```

```python title="Integration Example"
def process_insurance_claim(extracted_data):
    """Process insurance claim intake"""
    
    # Verify policy
    policy = verify_policy(
        policy_number=extracted_data['policyholder']['policyNumber'],
        name=extracted_data['policyholder']['name'],
        dob=extracted_data['policyholder'].get('dateOfBirth')
    )
    
    if not policy['active']:
        return {
            'status': 'rejected',
            'reason': 'Policy not active',
            'action': 'transfer_to_agent'
        }
    
    # Check coverage
    coverage = check_coverage(
        policy_type=policy['type'],
        incident_type=extracted_data['incident']['type'],
        incident_date=extracted_data['incident']['date']
    )
    
    # Create claim
    claim = {
        'claimNumber': generate_claim_number(),
        'policyholder': extracted_data['policyholder'],
        'incident': extracted_data['incident'],
        'damages': extracted_data.get('damages', {}),
        'status': 'intake_complete',
        'coveredAmount': coverage['estimated_coverage'],
        'deductible': coverage['deductible']
    }
    
    # Handle injuries
    if injuries := extracted_data.get('damages', {}).get('injuries'):
        for injury in injuries:
            if injury.get('medicalTreatment'):
                claim['requires_medical_review'] = True
                schedule_medical_review(claim['claimNumber'], injury)
    
    # Handle emergency situations
    if extracted_data.get('urgency') == 'emergency':
        claim['priority'] = 'high'
        dispatch_emergency_adjuster(claim)
        
        # Arrange temporary solutions
        if extracted_data['incident']['type'] == 'property':
            arrange_emergency_repairs(extracted_data['incident']['location'])
        elif extracted_data['incident']['type'] == 'auto':
            arrange_rental_car(extracted_data['policyholder'])
    
    # Documentation requirements
    required_docs = determine_required_documentation(
        incident_type=extracted_data['incident']['type'],
        damages=extracted_data.get('damages'),
        amount=extracted_data.get('damages', {}).get('estimatedTotalLoss', 0)
    )
    
    # Create claim record
    claim_id = save_claim(claim)
    
    # Send confirmation
    send_claim_confirmation(
        email=extracted_data['policyholder']['email'],
        claim_number=claim['claimNumber'],
        next_steps=required_docs,
        adjuster_contact=claim.get('assigned_adjuster')
    )
    
    return {
        'claimNumber': claim['claimNumber'],
        'status': 'accepted',
        'estimatedProcessingTime': estimate_processing_time(claim),
        'requiredDocuments': required_docs,
        'nextSteps': generate_next_steps(claim)
    }
```
</CodeBlocks>

## Financial services application

Process loan or credit applications with financial information.

<CodeBlocks>
```json title="Schema"
{
  "name": "Financial Application",
  "type": "ai",
  "description": "Extract loan or credit application information",
  "schema": {
    "type": "object",
    "properties": {
      "applicant": {
        "type": "object",
        "properties": {
          "personalInfo": {
            "type": "object",
            "properties": {
              "firstName": {
                "type": "string"
              },
              "lastName": {
                "type": "string"
              },
              "ssn": {
                "type": "string",
                "pattern": "^\\d{3}-\\d{2}-\\d{4}$",
                "description": "Social Security Number (XXX-XX-XXXX)"
              },
              "dateOfBirth": {
                "type": "string",
                "format": "date"
              },
              "email": {
                "type": "string",
                "format": "email"
              },
              "phone": {
                "type": "string"
              },
              "currentAddress": {
                "type": "object",
                "properties": {
                  "street": {
                    "type": "string"
                  },
                  "city": {
                    "type": "string"
                  },
                  "state": {
                    "type": "string"
                  },
                  "zipCode": {
                    "type": "string"
                  },
                  "yearsAtAddress": {
                    "type": "number"
                  },
                  "rentOrOwn": {
                    "type": "string",
                    "enum": ["rent", "own", "other"]
                  }
                }
              }
            },
            "required": ["firstName", "lastName", "dateOfBirth"]
          },
          "employment": {
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": ["employed", "self-employed", "unemployed", "retired", "student"]
              },
              "employer": {
                "type": "string",
                "description": "Employer name"
              },
              "position": {
                "type": "string",
                "description": "Job title"
              },
              "yearsEmployed": {
                "type": "number"
              },
              "annualIncome": {
                "type": "number",
                "minimum": 0,
                "description": "Annual gross income"
              },
              "otherIncome": {
                "type": "number",
                "description": "Other income sources"
              },
              "incomeVerifiable": {
                "type": "boolean",
                "description": "Can provide income verification"
              }
            },
            "required": ["status", "annualIncome"]
          },
          "financial": {
            "type": "object",
            "properties": {
              "creditScore": {
                "type": "integer",
                "minimum": 300,
                "maximum": 850,
                "description": "Self-reported credit score"
              },
              "monthlyDebt": {
                "type": "number",
                "description": "Total monthly debt payments"
              },
              "bankruptcyHistory": {
                "type": "boolean",
                "description": "Any bankruptcy in past 7 years"
              },
              "existingAccounts": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": ["checking", "savings", "credit-card", "mortgage", "auto-loan", "student-loan"]
                },
                "description": "Existing accounts with institution"
              }
            }
          }
        }
      },
      "loanDetails": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["personal", "auto", "mortgage", "home-equity", "business", "student"],
            "description": "Type of loan"
          },
          "amount": {
            "type": "number",
            "minimum": 0,
            "description": "Requested loan amount"
          },
          "purpose": {
            "type": "string",
            "description": "Purpose of the loan"
          },
          "term": {
            "type": "integer",
            "description": "Desired loan term in months"
          },
          "collateral": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": ["vehicle", "property", "savings", "none"],
                "description": "Type of collateral"
              },
              "value": {
                "type": "number",
                "description": "Estimated value of collateral"
              },
              "description": {
                "type": "string",
                "description": "Description of collateral"
              }
            }
          }
        },
        "required": ["type", "amount", "purpose"]
      },
      "coApplicant": {
        "type": "object",
        "properties": {
          "hasCoApplicant": {
            "type": "boolean"
          },
          "relationship": {
            "type": "string",
            "enum": ["spouse", "partner", "family", "business-partner", "other"]
          },
          "name": {
            "type": "string"
          },
          "income": {
            "type": "number"
          }
        }
      },
      "preferences": {
        "type": "object",
        "properties": {
          "preferredRate": {
            "type": "string",
            "enum": ["fixed", "variable", "no-preference"]
          },
          "automaticPayment": {
            "type": "boolean",
            "description": "Interested in automatic payment"
          },
          "paperless": {
            "type": "boolean",
            "description": "Prefers paperless statements"
          }
        }
      }
    },
    "required": ["applicant", "loanDetails"]
  }
}
```

```javascript title="Integration Example"
async function processFinancialApplication(extractedData) {
  const { applicant, loanDetails, coApplicant } = extractedData;
  
  // Initial eligibility check
  const eligibility = await checkEligibility({
    creditScore: applicant.financial?.creditScore,
    income: applicant.employment.annualIncome,
    employmentStatus: applicant.employment.status,
    loanAmount: loanDetails.amount,
    loanType: loanDetails.type
  });
  
  if (!eligibility.qualified) {
    return {
      status: 'declined',
      reason: eligibility.reason,
      alternatives: suggestAlternatives(eligibility, loanDetails)
    };
  }
  
  // Calculate debt-to-income ratio
  const monthlyIncome = (applicant.employment.annualIncome + 
                        (applicant.employment.otherIncome || 0)) / 12;
  const dti = (applicant.financial?.monthlyDebt || 0) / monthlyIncome;
  
  // Risk assessment
  const riskScore = calculateRiskScore({
    creditScore: applicant.financial?.creditScore,
    dti,
    employmentYears: applicant.employment.yearsEmployed,
    bankruptcyHistory: applicant.financial?.bankruptcyHistory,
    collateral: loanDetails.collateral,
    existingCustomer: applicant.financial?.existingAccounts?.length > 0
  });
  
  // Determine loan terms
  const terms = generateLoanTerms({
    loanType: loanDetails.type,
    amount: loanDetails.amount,
    term: loanDetails.term,
    riskScore,
    preferredRate: extractedData.preferences?.preferredRate,
    hasCollateral: loanDetails.collateral?.type !== 'none'
  });
  
  // Create application
  const applicationId = await createApplication({
    applicant,
    loanDetails,
    coApplicant: coApplicant?.hasCoApplicant ? coApplicant : null,
    eligibility,
    riskScore,
    proposedTerms: terms,
    status: determineInitialStatus(riskScore, loanDetails.amount)
  });
  
  // Handle co-applicant
  if (coApplicant?.hasCoApplicant) {
    await requestCoApplicantInfo(applicationId, coApplicant);
  }
  
  // Schedule next steps
  if (riskScore.requiresManualReview) {
    await assignToUnderwriter(applicationId, riskScore.reviewReasons);
  } else if (riskScore.preApproved) {
    await sendPreApprovalLetter(applicant.personalInfo.email, terms);
  }
  
  // Set up document collection
  const requiredDocs = determineRequiredDocuments({
    loanType: loanDetails.type,
    amount: loanDetails.amount,
    employmentStatus: applicant.employment.status,
    incomeVerifiable: applicant.employment.incomeVerifiable
  });
  
  await sendDocumentRequest(applicant.personalInfo.email, requiredDocs);
  
  return {
    applicationId,
    status: terms.status,
    preApproved: riskScore.preApproved,
    estimatedRate: terms.rate,
    monthlyPayment: terms.monthlyPayment,
    requiredDocuments: requiredDocs,
    nextSteps: generateApplicationNextSteps(riskScore, requiredDocs)
  };
}
```
</CodeBlocks>

## Best practices for complex schemas

<CardGroup cols={2}>
  <Card title="Modular design" icon="puzzle-piece">
    Break complex schemas into reusable object definitions for maintainability
  </Card>
  
  <Card title="Progressive extraction" icon="layer-group">
    Start with essential fields as required, make detailed fields optional
  </Card>
  
  <Card title="Clear descriptions" icon="comment">
    Add descriptions to every field to help AI understand context
  </Card>
  
  <Card title="Validation balance" icon="balance-scale">
    Use constraints for data quality but avoid being too restrictive
  </Card>
</CardGroup>

## Testing recommendations

### Test scenarios

Always test your structured outputs with these scenarios:

1. **Complete information** - All fields mentioned clearly
2. **Partial information** - Some required fields missing
3. **Ambiguous data** - Unclear or conflicting information
4. **Edge cases** - Boundary values, special characters
5. **Real conversations** - Actual call recordings or transcripts

### Monitoring checklist

Track these metrics for production deployments:

- Extraction success rate per field
- Average extraction time
- Token usage and costs
- Schema validation failures
- Most commonly missing fields

## Integration patterns

### Webhook processing

```javascript
// Robust webhook handler with error handling
app.post('/vapi/structured-output', async (req, res) => {
  try {
    const { type, call } = req.body;
    
    if (type !== 'call.ended') {
      return res.status(200).send('OK');
    }
    
    const outputs = call.artifact?.structuredOutputs || {};
    
    for (const [outputId, data] of Object.entries(outputs)) {
      if (!data.result) {
        console.error(`Extraction failed for ${data.name}`);
        await notifyExtractionFailure(call.id, data.name);
        continue;
      }
      
      try {
        await processExtractedData(data.name, data.result);
      } catch (error) {
        console.error(`Processing failed for ${data.name}:`, error);
        await queueForRetry(call.id, outputId, data);
      }
    }
    
    res.status(200).send('OK');
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).send('Internal error');
  }
});
```

### Batch processing

```python
def batch_process_extractions(call_ids):
    """Process multiple calls in batch"""
    
    results = []
    
    for call_id in call_ids:
        call = vapi.calls.get(call_id)
        outputs = call.artifact.get('structuredOutputs', {})
        
        for output_id, data in outputs.items():
            if data['result']:
                results.append({
                    'call_id': call_id,
                    'output_name': data['name'],
                    'data': data['result'],
                    'extracted_at': call.ended_at
                })
    
    # Bulk insert to database
    if results:
        bulk_insert_extracted_data(results)
    
    return len(results)
```

## Related resources

- [Structured outputs overview](/assistants/structured-outputs) - Main documentation
- [Quickstart guide](/assistants/structured-outputs-quickstart) - Get started quickly
- [API reference](/api-reference#structured-output) - Complete API documentation
- [JSON Schema specification](https://json-schema.org/) - JSON Schema standard